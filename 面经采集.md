### MySQL行锁是否会有死锁的情况？



### 从可重入锁出发， 要求写出基于可重入锁的阻塞队列，怎么实现。

### String直接复制与使用new String的区别

String类详解

源码：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0
    //...
}
```

String底层是被final关键字修饰的char数组，String类不能被继承，它的成员方法都默认为final方法，字符串一旦创建就不能再修改。

内存分配：

在Java的内存分配中，总共3种常量池，分别是**Class常量池**、**运行时常量池**、**字符串常量池**。

JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性，**常量池中一定不存在两个相同的字符串**。

对象生成方案：

- 通过字面量赋值创建字符串

  如 String s = "test", 可能创建一个或者不创建对象。先在常量池中查找是否存在相同的字符串（如 String s = "test"），若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。

  <img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20211101215359886.png" alt="image-20211101215359886" style="zoom:80%;" />

- 通过new关键字创建字符串

  如 String s = new String("test"), 至少会创建一个对象，也可能会创建两个对象。因为用到new关键字，肯定会在堆中创建一个String对象，如果字符池中已经存在"test",则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象。

  <img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20211101220046930.png" alt="image-20211101220046930" style="zoom:80%;" />

intern方法：

返回字符串对象的规范化表示形式

- 1.7之前

  查询常量池中是否有字符串存在，如果存在，则返回常量池中的引用。如果在常量池找不到对应的字符串，则将字符串拷贝到常量池中。

- 1.7之后

  查询常量池中是否有字符串存在，如果存在，则返回常量池中的引用。如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。

  <img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20211101222828697.png" alt="image-20211101222828697" style="zoom:80%;" />

常量字符串的拼接操作：

- 常量字符串的“+”操作，编译阶段直接会合成为一个字符串。如string str=”JA”+”VA”，在编译阶段会直接合并成语句String str=”JAVA”，于是会去常量池中查找是否存在”JAVA”,从而进行创建或引用。
- 对于final字段，编译期直接进行了常量替换（而对于非final字段则是在运行期进行赋值处理的）。
  final String str1=”ja”;
  final String str2=”va”;
  String str3=str1+str2;
  在编译时，直接替换成了String str3=”ja”+”va”，根据第三条规则，再次替换成String str3=”JAVA”
- 常量字符串和变量拼接时（如：String str3=baseStr + “01”;）会调用stringBuilder.append()在堆上创建新的对象。

示例：

<img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20211101223538265.png" alt="image-20211101223538265" style="zoom:80%;" />

其他相关：jdk1.7之前，常量池放在方法区，jdk1.7之后，常量池放在堆内存。

参考博文：

[几张图轻松理解String.intern()](https://blog.csdn.net/tyyking/article/details/82496901)

[String直接赋值与使用new String的区别](https://www.cnblogs.com/wwct/p/12795827.html)(https://www.cnblogs.com/wwct/p/12795827.html)

[字符串常量池、运行时常量池、class常量池分别到底都在哪？](https://blog.csdn.net/fascinate_/article/details/113737923?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.1)

### 线程顺序执行

https://www.cnblogs.com/wenjunwei/p/10573289.html

https://blog.csdn.net/xiarufeng/article/details/89084444

