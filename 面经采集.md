### MySQL行锁是否会有死锁的情况？



### 从可重入锁出发， 要求写出基于可重入锁的阻塞队列，怎么实现。

### String直接复制与使用new String的区别

String类详解

源码：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0
    //...
}
```

String底层是被final关键字修饰的char数组，String类不能被继承，它的成员方法都默认为final方法，字符串一旦创建就不能再修改。

内存分配：

在Java的内存分配中，总共3种常量池，分别是**Class常量池**、**运行时常量池**、**字符串常量池**。

JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性，**常量池中一定不存在两个相同的字符串**。

对象生成方案：

- 通过字面量赋值创建字符串

  如 String s = "test", 可能创建一个或者不创建对象。先在常量池中查找是否存在相同的字符串（如 String s = "test"），若存在，则将栈中的引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。

  <img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20211101215359886.png" alt="image-20211101215359886" style="zoom:80%;" />

- 通过new关键字创建字符串

  如 String s = new String("test"), 至少会创建一个对象，也可能会创建两个对象。因为用到new关键字，肯定会在堆中创建一个String对象，如果字符池中已经存在"test",则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象。

  <img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20211103104018156.png" alt="image-20211103104018156" style="zoom:80%;" />

intern方法：

返回字符串对象的规范化表示形式

- 1.7之前

  查询常量池中是否有字符串存在，如果存在，则返回常量池中的引用。如果在常量池找不到对应的字符串，则将字符串拷贝到常量池中。

- 1.7之后

  查询常量池中是否有字符串存在，如果存在，则返回常量池中的引用。如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。

  <img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20211103103817097.png" alt="image-20211103103817097" style="zoom:80%;" />

常量字符串的拼接操作：

- 常量字符串的“+”操作，编译阶段直接会合成为一个字符串。如string str=”JA”+”VA”，在编译阶段会直接合并成语句String str=”JAVA”，于是会去常量池中查找是否存在”JAVA”,从而进行创建或引用。
- 对于final字段，编译期直接进行了常量替换（而对于非final字段则是在运行期进行赋值处理的）。
  final String str1=”ja”;
  final String str2=”va”;
  String str3=str1+str2;
  在编译时，直接替换成了String str3=”ja”+”va”，根据第三条规则，再次替换成String str3=”JAVA”
- 常量字符串和变量拼接时（如：String str3=baseStr + “01”;）会调用stringBuilder.append()在堆上创建新的对象。

示例：

<img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20211101223538265.png" alt="image-20211101223538265" style="zoom:80%;" />

其他相关：jdk1.7之前，常量池放在方法区，jdk1.7之后，常量池放在堆内存。

参考博文：

[几张图轻松理解String.intern()](https://blog.csdn.net/tyyking/article/details/82496901)

[String直接赋值与使用new String的区别](https://www.cnblogs.com/wwct/p/12795827.html)(https://www.cnblogs.com/wwct/p/12795827.html)

[字符串常量池、运行时常量池、class常量池分别到底都在哪？](https://blog.csdn.net/fascinate_/article/details/113737923?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.1)

### 线程顺序执行

https://www.cnblogs.com/wenjunwei/p/10573289.html

https://blog.csdn.net/xiarufeng/article/details/89084444

### mysql模糊查询导致索引失效

like关键字后使用了左模糊匹配或者使用了左右模糊匹配时，索引不会被SQL执行器使用，SQL查询字段不是联合索引的最左字段时，联合索引也不会被SQL执行器使用。这其中的原因是，MySQL中的索引索引树检索遵循最左匹配原则，B-tree索引树的叶子节点的有序性，也是建立在最左匹配的基础上的，如果直接使用索引键的中部或者后部进行SQL查询，由于违背了最左匹配原则，MySQL的SQL执行器无法利用这个索引树进行检索，所以给我们的直观感受就是索引失效了。

https://blog.csdn.net/xue_mind/article/details/117698061

### 单例模式的双重校验机制

**第一次校验**：

也就是第一个if（singleton==null），这个是为了代码提高代码执行效率，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getInstance方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。

**第二次校验**：

也就是第二个if（singleton\==null），这个校验是防止二次创建实例，假如有一种情况，当singleton还未被创建时，线程t1调用getInstance方法，由于第一次判断singleton==null，此时线程t1准备继续执行，但是由于资源被线程t2抢占了，此时t2页调用getInstance方法，同样的，由于singleton并没有实例化，t2同样可以通过第一个if，然后继续往下执行，同步代码块，第二个if也通过，然后t2线程创建了一个实例singleton。此时t2线程完成任务，资源又回到t1线程，t1此时也进入同步代码块，如果没有这个第二个if，那么，t1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。

**所以说：两次校验都必不可少。**

还有，这里的代码

```java
private static volatile Singleton singleton = null;
```

中的volatile也必不可少，volatile关键字可以防止jvm指令重排优化，因为 singleton = new Singleton() 这句话可以分为三步：

> 1、为 singleton 分配内存空间；
> 2、初始化 singleton；
> 3、将 singleton 指向分配的内存空间。

但是由于JVM具有指令重排的特性，执行顺序有可能变成1-3-2。指令重排在单线程下不会出现问题，但是在多线程下会导致一个线程获得一个未初始化的实例。例如：线程T1执行了1和3，此时T2调用getInstance()后发现singleton 不为空，因此返回singleton，但是此时的singleton 还没有被初始化。

使用volatile会禁止JVM指令重排，从而保证在多线程下也能正常执行。

这里还说一下volatile关键字的第二个作用，保证变量在多线程运行时的可见性：

在JDK1.2之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的Java内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就 可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。要解决这个问题，就需要把变量声明为volatile，这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。

### TCP粘包

### MySQL主从同步

### ArrayList和LinkedList

### HashMap ConcurrentHashMap

### 进程和线程

### Synchronized和ReentrantLock

synchronized属于原生语法层面的互斥锁，ReentrantLock是API层面的互斥锁，相比于synchronized增加了一些高级功能：等待可中断、可实现公平锁，以及锁可以绑定多个条件。

- 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
- 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
- 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。

### AQS

### 可达性分析

可作为gc root的对象

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中静态变量引用的对象
- 方法区中常量引用的对象
- 本地方法栈中引用的对象

强、软、弱、虚引用

### MVCC多版本并发控制

提高并发的技术，避免了加锁操作。

- 只在读已提交、可重复读两种隔离级别下工作
- InnoDB引擎支持
- 可以使用乐观锁和悲观锁来实现
- 应对高并发事务，MVCC比单纯的加锁更有效

MVCC有两种实现方式，第一种实现方式是将数据记录的多个版本保存在数据库中，当这些不同版本数据不再需要时，垃圾收集器回收这些记录。这个方式被PostgreSQL和Firebird/Interbase采用，SQL Server使用的类似机制，所不同的是旧版本数据不是保存在数据库中，而保存在不同于主数据库的另外一个数据库tempdb中。第二种实现方式只在数据库保存最新版本的数据，但是会在使用undo时动态重构旧版本数据，这种方式被Oracle和MySQL/InnoDB使用。

实现机制

MVCC可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作，因此开销更低。MVCC的实现大都都实现了非阻塞的读操作，写操作也只锁定必要的行。InnoDB的MVCC实现，是通过保存数据在某个时间点的快照来实现的。**一个事务，不管其执行多长时间，其内部看到的数据是一致的**。也就是事务在执行的过程中不会相互影响。下面我们简述一下MVCC在InnoDB中的实现。

　　InnoDB的MVCC，**通过在每行记录后面保存两个隐藏的列来实现：一个保存了行的创建时间，一个保存行的过期时间（删除时间），当然，这里的时间并不是时间戳，而是系统版本号，每开始一个新的事务，系统版本号就会递增**。在RR隔离级别下，MVCC的操作如下：

1. select操作。
   - **InnoDB只查找版本早于（包含等于）当前事务版本的数据行**。可以确保事务读取的行，要么是事务开始前就已存在，或者事务自身插入或修改的记录。
   - **行的删除版本要么未定义，要么大于当前事务版本号**。可以确保事务读取的行，在事务开始之前未删除。
2. insert操作。将新插入的行保存当前版本号为行版本号。
3. delete操作。将删除的行保存当前版本号为删除标识。
4. update操作。变为insert和delete操作的组合，insert的行保存当前版本号为行版本号，delete则保存当前版本号到原来的行作为删除标识。

　　由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是**将删除版本号小于当前系统版本的行删除**，这个过程叫做purge。
