### 单例模式

确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例

**实现方式**

- 饿汉式

  ```java
  public class Singleton{
      private static Singleton instance = new Singleton();
      private Singleton(){}
      public static Singleton getInstance(){
          return instance;
      }
  }
  ```

- 懒汉式

  ```java
  public class Singleton{
      private static Singleton instance;
      private Singleton(){}
      public static Singleton getInstance(){
          if(instance == null){
              instance =  new Singleton();
          }
          return instance;
      }
  }
  ```

- 双重校验锁

  ```java
  public class Singleton{
      private volatile static Singleton instance = null; //volatile是必要的，避免重排序
      private Singleton(){}
      public static Singleton getInstance(){
          if(instance == null){ //第一次检查
              synchronized(Singleton.class){ //加锁
                  if(instance == null){ //第二次检查
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
  ```

  > volatile作用：避免指令重排序。instance = new Singleton()在执行过程中经历了三步：（1）memory = allocate() //分配对象内存空间 （2）ctorInstance(memory) //初始化对象 （3）instance = memory //设置instance执行memory地址。不使用volatile可能会导致3、2重排序，多线程环境下，某个线程获取的instance可能为null。

- 静态内部类

  > JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。基于这个特性，可以实现另一种线程安全的延迟初始化方案.

  ```java
  public class Singleton{
      private Singleton(){}
      private static class Holder{
          private final static Singleton instance = new Singleton();
      }
      public static Singleton getInstance(){
          return Holder.instance;
      }
  }
  ```

### 状态模式

投票次数限制