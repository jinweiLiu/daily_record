## JAVA并发

### 锁的概述

#### 乐观锁与悲观锁

悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败，则说明其他数据正在被其他线程修改，当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。

乐观锁是相对悲观锁来说的，它认为数据在一般情况下才不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会对数据冲突与否进行检测。

#### 公平锁与非公平锁

根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁则在运行时闯入，也就是先来不一定先得。

ReentrantLock提供了公平和非公平锁得实现。

- 公平锁：ReentrantLock pairLock = new ReentrantLock（true）。
- 非公平锁：ReentrantLock pairLock = new ReentrantLock（false）。如果构造函数不传递参数，则默认是非公平锁。

**在没有公平性需求得前提下尽量使用非公平锁，因为公平锁会带来性能开销。**

#### 独占锁与共享锁

根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。

独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock就是以独占方式实现得。共享锁则可以同时由多个线程持有，例如ReadWriteLock读写锁，它允许一个资源可以白多个线程同时进行读操作。

独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据得一致性，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。

共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行操作。

#### 可重入锁 

当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时是否会被阻塞？如果不被阻塞，那么我们说是可重入的，也就是只要该线程获取了该锁，那么可以无限次数地进入被该锁锁住的代码。synchronized和ReentrantLock都是可重入锁。

```java
//示例
public class Hello{
    public synchronized void helloA(){
        System.out.println("hello");
    }
    public synchronized void helloB(){
        System.out.println("hello B");
        helloA();
    }
}
```

#### 自旋锁

由于Java中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU使用权的情况下，多次尝试获取（默认次数是10，可以使用-XX:PreBlockSpinsh参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用CPU时间换取线程阻塞与调度的开销，但是很有可能这些CPU时间白白浪费了。

### AQS

## JVM

### 参数设置

| 参数 | 含义               | 默认值               | 示例   | 说明                                                         |
| ---- | ------------------ | -------------------- | ------ | ------------------------------------------------------------ |
| -Xms | 初始堆大小         | 物理内存的1/64(<1GB) | -Xms1g | 默认，空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制   |
| -Xmx | 最大堆大小         | 物理内存的1/4(<1GB)  | -Xmx1g | 默认，空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制     |
| -Xss | 每个线程的堆栈大小 |                      |        | JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右<br/>一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。 |

