#### 数据库索引

- 索引创建

  创建表时创建(unique 代表唯一索引  fulltext代表全文索引  spatial代表空间索引)

  > create table student(
  >
  > ​    id int primary key,
  >
  > ​    name varchar(255),
  >
  > ​    sex varchar(10),
  >
  > ​    index(name)
  >
  > )

  使用create index创建索引(不能创建主键索引)

  > create index index_name on table_name(column_list)

  使用alter table创建索引

  > alter table table_name add index index_name (column_list)

- 数据库索引结构

  MySQL采用B+ tree的数据结构构建索引

  - B tree

    <img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20210712164806070.png" alt="image-20210712164806070" style="zoom:80%;" />

    B tree称为平衡多路搜索树，它基于在二叉树的基础上采用多叉树，再使用平衡二叉树的思想。

    1. 所有键值分布在整颗树中；
    2. 任何一个关键字出现且只出现在一个结点中；
    3. 搜索有可能在非叶子结点结束；
    4. 在关键字全集内做一次查找,性能逼近二分查找

  - B+ tree

    <img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20210712164923359.png" alt="image-20210712164923359" style="zoom:80%;" />

    B+树是B-树的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于:

    1. 所有关键字存储在叶子节点出现,内部节点(非叶子节点并不存储真正的 data)
    2. 为所有叶子结点增加了一个链指针（对于范围查询有利）

- 索引分析

  explain用来分析SQL语句的查询情况，它包含id、select_type、table、type、possible_keys、key、key_len、ref、rows、extra字段

<img src="C:\Users\jwliu\AppData\Roaming\Typora\typora-user-images\image-20210712113108029.png" alt="image-20210712113108029" style="zoom: 50%;" />

- 索引使用策略

  - 匹配全值索引查询：针对建索引的列的全值进行查询。

  - 匹配最左前缀索引查询：索引不仅可以进行单列索引，也可以建立联合索引，也就是把多列建成一个联合索引匹配列。

    例如，把学生表中的姓名name、性别sex、年龄age建立成联合索引，按照最左前缀匹配原则，它可以匹配name单独一列，可以匹配name、sex两列，可以匹配name、sex、age三列，但是不能匹配sex或者age单独列，不能匹配name、age列或者sex、age列。

  - 匹配列前缀索引查询：匹配列的前一部分进行查询，如查询姓名，可以按姓氏“刘”开头进行查询，使用通配%，但是通配符只能放置在右侧，不能放置在左侧。

  - 匹配值的范围索引查询：对索引可以进行范围查询。

  - 仅对索引进行查询：只针对索引进行查询，也叫索引覆盖，不查询数据表。例如，在年龄上建立索引后，查询的时候只查询年龄，这样它可以通过索引树上的年龄值获取年龄数据。

- 索引类型

  - 主键索引，根据表的主键建立索引，称为主键索引。主键索引是不允许重复和不允许有空值的，它是唯一索引的一种特例。

  - 普通索引，最基本的索引，没有任何限制，可以在创建表的时候创建索引，可以创建表后直接创建索引，也可以修改表结构的方式添加索引。

  - 唯一索引，要求列值不允许重复，但是允许有空值，主键索引就是唯一索引的特例。也可以通过联合索引来创建唯一索引，要求列值的组合必须唯一，需要使用关键子UNIQUE来标识唯一索引。

  - 聚簇索引和非聚簇索引

    聚簇索引是将数据存放在索引树的叶子节点上，找到叶子节点就可以读取这行数据。InnoDB存储引擎的索引方式就是聚簇索引。一个表只能有一个聚簇索引，一般会根据主键或者唯一索引，或者以数据库内部生成的rowid为主键，来建立聚簇索引。

    非聚簇索引是在索引树的叶子节点上存放数据的地址，找到该地址后，需要到磁盘中查询一次才能获取到数据。MyISAM存储引擎的索引方式就是非聚簇索引，只在索引树的叶子节点上存放地址。

- 索引不生效情况

  - 不等于（<>、!=），使用不等于操作符进行条件判断时时不能使用索引的

  - 前导模糊查询（%xx%），使用前导模糊查询不能使用索引，但是后导模糊查询（xx%）时可以使用索引的。

  - 比较不匹配的数据类型，比较不匹配的数据类型是指某一列在比较查询时，假如列是varchar字符串类型，但是在赋值的时候赋值int整型，这时这一列即使有索引，也不会使用到索引。

  - or连接条件，在SQL语句的条件中，用OR连接的条件表达式不能使用索引。

  - 条件表达式前使用函数，在SQL语句的条件中，在表达式前使用函数或者运算操作，不能使用索引；在表达式后使用函数或者运算操作，可以使用索引。

    select * from student where id + 1 = 1  不使用索引 

    select * from student where id  = 1 + 1  使用索引

- 索引利弊

  优势：

  > (1) 提高查询效率，它可以通过创建唯一索引或者主键索引来标识行的唯一性，在查询的时候可以快速定位到要查询的行数据
  >
  > (2) 可以加快表与表之间的连接查询
  >
  > (3) 在分组和排序的时候可以极大地节省时间，使用索引可以进行快速排序，分组查询时虽然不能直接使用索引，但是分组查询要先进行排序，而在排序阶段就会减少时间，所以分组查询也能节省时间
  >
  > (4) 使用索引来进行查询、排序、分组，使用优化隐藏器提高系统的性能

  劣势：

  > (1) 创建索引和维护索引需要耗费时间，随着数据量的增大，时间也会逐渐增加
  >
  > (2) 索引文件的大小会逐渐增大，索引文件需要占用物理空间，如果建立聚簇索引，文件大小会更大，会使数据库的存储逐渐变大
  >
  > (3) 对表进行增加、修改、删除的时候，都需要对索引进行维护，这会影响对表和数据的操作速度，延长对表的操作时间

- 索引建立的原则

  > - 主键的字段需要建立唯一索引或者唯一索引
  > - 用于连接查询的字段可以建立索引
  > - 经常用来排序的字段可以建立索引
  > - 频繁使用where的条件字段可以建立索引
  > - 唯一性太差的字段不适合建立索引
  > - 更新频率远大于查询的字段不适合建立索引
  > - 不会出现where条件表达式的字段不适合建立索引
  > - 对于类型为text、blob、image、bit的字段，不适合建立索引

#### 数据库锁

相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点式不同的存储引擎支持不同的锁机制。MyISAM存储引擎采用的是表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下是采用行级锁。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率低，并发度也最高。

- **MyISAM表锁**

  **简述**

  MySQL的表级锁有两种模式：表共享读锁和表独占写锁。可见，对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！

  **如何加锁**

  MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。

- **InnoDB锁**

  **简述**

  InnoDB相对于MyISAM最大的区别是支持事务和行级锁。InnoDB实现了游戏啊两种类型的行锁：

  共享锁：允许一个事务去读一行，组织其他事务获得相同数据集的排他锁。

  排他锁：允许获得排他锁的事务更新数据，组织其他事务取得相容数据集的共享读锁和排他写锁。

  另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁：

  意向共享锁：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须取得该锁的意向共享锁。

  意向排他锁：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的意向排他锁。

  **如何加锁**

  共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHAREMODE。

  排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE

#### 读写分离

都分库分表了，为什么还要做读写分离？其实，读写分离跟分库分表解决的问题都是一样的。读写分离也是分库的一种。

例如，一个项目单库达到TPS1K，QPS2k，基本就很慢了。这个时候如果将单库拆成两个完全一样结构的库，一个负责写，一个负责读，这样就可以很好的进行处理性能。

读写分离，就需要用到主从同步技术。如果是写多读少，可以使用分库分表，或者M-M-S架构；如果读多写少，可以使用M-S-S，扩展4~5个S都是可以。

**MySQL主从复制原理：**主库将变更写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。

这里就有一个问题了。有数据传输就会有间延，一旦并发量大就有可能造成较大的间延，也产生了主从延时问题。

**如何解决主从延时问题？**

1、分库，将一个主库拆分为4个主库，每个主库的写并发就500/s，此时主从延迟可以忽略不计。
 2、打开mysql支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了2000/s，并行复制还是没意义。28法则，很多时候比如说，就是少数的几个订单表，写入了2000/s，其他几十个表10/s。（**所谓并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。**）
 3、直接查主库（不推荐）
 4、检查代码，一般INSERT/UPDATE后，马上进行SELECT，这种代码要避免。

#### 分库分表

分库分表包括分库和分表两个部分，更进一步可以划为：垂直分库、水平分库、垂直分表、水平分表。

- 垂直分库
  - 概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
  - 结果：
    - 每个库的结构都不一样
    - 每个库的数据也不一样，没有交集
    - 所有库的并集是全量数据
  - 场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。
- 垂直分表
  - 概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同表中。
  - 结果：
    - 每个表的结构都不一样
    - 每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据
    - 所有表的并集是全量数据
  - 场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。
- 水平分库
  - 概念：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
  - 结果：
    - 每个库的结构都一样
    - 每个库的数据都不一样，没有交集
    - 所有库的并集是全量数据
  - 场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。
- 水平分表
  - 以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
  - 结果：
    - 每个表的结构都一样
    - 每个表的数据都不一样，没有交集
    - 所有表的并集是全量数据
  - 场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重CPU负担，以至于成为瓶颈。

#### 事务机制

原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节.事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。

隔离性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。比如A向B转账，不可能A扣了钱，B却没收到。（也可以理解为系统从一个正确的状态，迁移到另一个正确的状态）。

一致性：同一时间，只允许一个事务请求同一数据，不同事务之间彼此没有干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

持久性：指一个事务一旦提交，它对数据库中数据的改变就应该是永久的。接下来的其他操作或故障不应该对其执行结果有任何影响。

隔离级别：读未提交、读已提交、可重复读、串行化

- 脏读：当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
- 不可重复读：是指在一个事务内，多次读同一个数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
- 幻读：第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样，幻读是数据行记录变多了或者少了。

#### 多版本并发控制（MVCC）

只在RC和RR两个级别中生效，不加锁的实现方式。

视图（ReadView）：

- 快照读 => 普通读，不加锁。
- 当前读 => 读取的是最新版本，并且需要先获取对应记录的锁（for update, in share mode...）。
